
//emp.h file

#define ARRAY_ALLOC_FAIL NULL
#define INT_ALLOC_FAIL NULL
#define ARRAY_DEALLOC -1
#define ARRAY_FULL 9
#define INSERT_SUCCESS 1
#define FOUND 1
#define NOT_FOUND 0
#define NOT_UNIQUE 7
#define BKUP_ALLOC_FAIL NULL
#define UPTO_DATE 1
#define BKUP_REQUIRED 0
#define SUCCESS 1
#define ABORT -1
#define NAME_SIZE 15
#define DESIG_SIZE 20

struct _employee_
{
    int emp_id;
    char emp_name[NAME_SIZE];
    float emp_sal;
    char emp_desig[DESIG_SIZE];
    int age;
};
typedef struct _employee_ Employee;
struct _array_
{
    Employee *arr;
    int *bkup;
    int c_size, t_size;
    int bkup_status;
};
typedef struct _array_ Array;

Array * initialise_array(int);
int insert_data(Array *, Employee data);
int search(Array *, int empid);
void display(Array *);
void sort_by_age(Array *);

//Practice problems
float get_average_hr_salary(Array *);
Employee get_employee_details(Array *, char *emp_name);
int terminate_employee(Array *, int emp_id);
int count_employees_by_location(Array *, char *location);
Array * deallocate(Array *);




//emp.op.c file

#include<stdlib.h>
#include<stdio.h>
#include <assert.h>
#include "employee.h"

Array * initialise_array(int size)
{
    Array *my_arr;
    my_arr =(Array *)malloc(sizeof(Array));
    if(NULL == my_arr) return ARRAY_ALLOC_FAIL;

    my_arr->c_size = 0;
    my_arr->t_size = size;
    my_arr->arr = (Employee *)malloc(sizeof(Employee) * size);
    my_arr->bkup_status = UPTO_DATE;

    if(NULL == my_arr->arr){
        free(my_arr);
        return INT_ALLOC_FAIL;
    }

    return my_arr;
}

int insert_data(Array *my_arr, Employee data)
{
    if(my_arr == NULL) return ARRAY_DEALLOC;

    if(my_arr->c_size == my_arr->t_size) return ARRAY_FULL;

    *(my_arr->arr + my_arr->c_size) = data;
    my_arr->c_size++;

    return INSERT_SUCCESS;
}
int search(Array *my_arr, int id)
{
    int i;

    for(i=0; i <my_arr->c_size; i++)
        if((my_arr->arr+i)->emp_id == id) return FOUND;
    return NOT_FOUND;
}

void sort_by_age(Array *my_arr)
{
    int i, j;
    Employee temp;
    int flag;
    for(i=0;i<my_arr->c_size; i++){
        flag = 0;
        for(j=0; j<my_arr->c_size-1-i; j++){
            if((my_arr->arr+j)->age > (my_arr->arr+j+1)->age){
                flag = 1;
                temp = my_arr->arr[j];
                my_arr->arr[j] = my_arr->arr[j+1];
                my_arr->arr[j+1] = temp;
            }
        }
        if(flag == 0) return;
    }
}

void display(Array *my_arr)
{
    int i;
    printf("\n");
    for(i=0; i<my_arr->c_size; i++)
        printf("\n%d %s %d %f %s",//
               (my_arr->arr+i)->emp_id,//
               (my_arr->arr+i)->emp_name, //
               (my_arr->arr+i)->age, //
               (my_arr->arr+i)->emp_sal, //
               (my_arr->arr+i)->emp_desig);
}

Array * deallocate(Array *my_arr)
{
    if(my_arr == NULL) return NULL;

    free(my_arr->arr);
    free(my_arr);

    return NULL;
}

//main.c file

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include<string.h>
#include "employee.h"

int main()
{
    Array *test;
    Employee emp;

    test = initialise_array(5);
    assert(test->c_size == 0);
    assert(test->t_size == 5);

    emp.emp_id = 1001;
    strcpy(emp.emp_name,"Raj");
    strcpy(emp.emp_desig,"HR");
    emp.age = 31;
    emp.emp_sal = 100000;
    assert(insert_data(test, emp));
    assert(test->c_size == 1);
    assert(test->arr->emp_id == 1001);

    emp.emp_id = 1002;
    strcpy(emp.emp_name,"Rajan");
    strcpy(emp.emp_desig,"HR Executive");
    emp.age = 24;
    emp.emp_sal = 120000;
    assert(insert_data(test, emp));

    emp.emp_id = 1003;
    strcpy(emp.emp_name,"Rajani");
    strcpy(emp.emp_desig,"HR");
    emp.age = 35;
    emp.emp_sal = 200000;
    assert(insert_data(test, emp));

    emp.emp_id = 1004;
    strcpy(emp.emp_name,"Rajesh");
    strcpy(emp.emp_desig,"SE");
    emp.age = 24;
    emp.emp_sal = 80000;
    assert(insert_data(test, emp));

    emp.emp_id = 1005;
    strcpy(emp.emp_name,"Rajiv");
    strcpy(emp.emp_desig,"HR");
    emp.age = 49;
    emp.emp_sal = 300000;
    assert(insert_data(test, emp));
    assert((test->arr+4)->emp_id == 1005);
    assert(test->c_size == 5);

    emp.emp_id = 1006;
    strcpy(emp.emp_name,"Rajiv");
    strcpy(emp.emp_desig,"Sr. Manager");
    emp.age = 49;
    emp.emp_sal = 300000;
    assert(insert_data(test, emp) == ARRAY_FULL);

    assert(search(test, 1001) == FOUND);
    assert(search(test, 1005) == FOUND);
    assert(search(test, 1006) == NOT_FOUND);
    sort_by_age(test);
    display(test);

    test = deallocate(test);
    assert(test == NULL);
    return 0;
}


//for linkedlist easy n simple code

//list.h file
#define NAME_SIZE 15
#define DESIG_SIZE 20
#define LOCATION_SIZE 20
#define ACTIVE 1
#define NOT_ON_ROLL -1
#define INSERT_FAIL -1
#define SUCCESS 1
#define PROMOTED 1
#define EMP_NOT_FOUND 0

struct _employee_
{
    int emp_id;
    char emp_name[NAME_SIZE];
    float emp_sal;
    char emp_desig[DESIG_SIZE];
    char emp_location[LOCATION_SIZE];
    int emp_status;
};
typedef struct _employee_ Emp;

struct _employee_node_
{
    Emp data;
    struct _employee_node_ *ptr;
};

typedef struct _employee_node_ Enode;

struct _emp_linked_list_
{
    Enode *head, *tail;
    int count;
};
typedef struct _emp_linked_list_ Emplist;

Emplist * initialise_emp_list();
int insert_employee(Emplist *,Emp emp_id);
// return SUCCESS if promoted, id not present
int give_promotion(Emplist *, int emp_id, char *desig);
int give_bonus(Emplist *, float);
int emp_count_on_location(Emplist *,char *location);
int fire_employee(Emplist *, int emp_id);
void emp_display(Emplist *);


//list_op.c file
#include<stdlib.h>
#include<stdio.h>
#include <string.h>
#include "employee.h"
#define IS_NULL(PTR) PTR == NULL
#define ALLOC_FAIL NULL

Emplist * initialise_emp_list()
{
    Emplist *emp;

    emp = (Emplist *)malloc(sizeof(Emplist));
    if(IS_NULL(emp)) return ALLOC_FAIL;

    emp->head =emp->tail = NULL;
    emp->count = 0;

    return emp;
}

Enode * get_node_employee(Emp data)
{
    Enode *new_node;

    new_node = (Enode *)malloc(sizeof(Enode));
    if(new_node == NULL) return ALLOC_FAIL;

    new_node->data = data;
    new_node->ptr = NULL;
    return new_node;
}
int insert_employee(Emplist *my_list, Emp emp_data)
{
    Enode *new_node = get_node_employee(emp_data);

    if(new_node == NULL) return INSERT_FAIL;

    if(my_list->head == NULL)
        my_list->head = my_list->tail = new_node;
    else{
        new_node->ptr = my_list->head;
        my_list->head = new_node;
    }
    my_list->count++;
    return SUCCESS;
}
// return SUCCESS if promoted, id not present
int give_promotion(Emplist *emp, int emp_id, char *desig)
{
    Enode *temp;

    for(temp = emp->head; temp != NULL; temp = temp->ptr)
    {
        if((temp->data).emp_id == emp_id)
        {
            strcpy((temp->data).emp_desig, desig);
            return PROMOTED;
        }
    }
    return EMP_NOT_FOUND;
}
int give_bonus(Emplist *, float);
int emp_count_on_location(Emplist *emp,char *location)
{
    Enode *temp;
    int count = 0;
    for(temp = emp->head; temp != NULL; temp = temp->ptr)
    {
        if(!strcmp((temp->data).emp_location,location))
            count++;
    }
    return count;
}
int fire_employee(Emplist *, int emp_id);

void emp_display(Emplist *emp)
{
    Enode *temp;

    for(temp = emp->head; temp != NULL; temp = temp->ptr)
    {
        printf("\nEmployee id: %d\n Employee Name: %s\n Employee Designation %s\n\n", //
               (temp->data).emp_id,//
               (temp->data).emp_name,
               (temp->data).emp_desig);
    }
}

//main.c file
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include<assert.h>
#include "employee.h"

int main()
{
    Emplist *test_emp;
    Emp emp_data;

    test_emp = initialise_emp_list();
    assert(test_emp->head == NULL);
    assert(test_emp->tail == NULL);
    assert(test_emp->count == 0);

    emp_data.emp_id = 1001;
    strcpy(emp_data.emp_name, "Raj");
    strcpy(emp_data.emp_desig,"Developer");
    strcpy(emp_data.emp_location, "Blore");
    emp_data.emp_sal = 100000;
    emp_data.emp_status = ACTIVE;

    assert(insert_employee(test_emp, emp_data));

    emp_data.emp_id = 1002;
    strcpy(emp_data.emp_name, "Rajiv");
    strcpy(emp_data.emp_desig,"Developer");
    strcpy(emp_data.emp_location, "Blore");
    emp_data.emp_sal = 10000;
    emp_data.emp_status = ACTIVE;

    assert(insert_employee(test_emp, emp_data));

    emp_data.emp_id = 1003;
    strcpy(emp_data.emp_name, "Rajani");
    strcpy(emp_data.emp_desig,"Manager");
    strcpy(emp_data.emp_location, "Chennai");
    emp_data.emp_sal = 400000;
    emp_data.emp_status = ACTIVE;

    assert(insert_employee(test_emp, emp_data));

    emp_data.emp_id = 1004;
    strcpy(emp_data.emp_name, "Rajat");
    strcpy(emp_data.emp_desig,"Developer");
    strcpy(emp_data.emp_location, "Chennai");
    emp_data.emp_sal = 100000;
    emp_data.emp_status = ACTIVE;

    assert(insert_employee(test_emp, emp_data));

    emp_data.emp_id = 1005;
    strcpy(emp_data.emp_name, "Raja");
    strcpy(emp_data.emp_desig,"Manager");
    strcpy(emp_data.emp_location, "Blore");
    emp_data.emp_sal = 300000;
    emp_data.emp_status = ACTIVE;

    assert(insert_employee(test_emp, emp_data));

    assert(test_emp->count == 5);
    assert((test_emp->head->data).emp_id == 1005);

    assert(give_promotion(test_emp,1004, "Sr. Developer"));
    assert(!strcmp((test_emp->head->ptr->data).emp_desig, "Sr. Developer"));
    emp_display(test_emp);

    assert(emp_count_on_location(test_emp,"Blore") == 3);
    return 0;
}

//for actual linkedlist program
//list_h file
#ifndef LIST_HEADER
#define LIST_HEADER
#define ALLOC_FAIL NULL
#define NODE_ALLOC_FAIL NULL
#define SUCCESS 1
#define INSERT_FAIL 0
#define NOT_FOUND 0
#define FOUND 1
#define LIST_EMPTY -1
struct _node_
{
    int data;
    struct _node_ *ptr;
};
typedef struct _node_ Node;

struct _linked_list_
{
    Node *head, *tail;
    int count;
};
typedef struct _linked_list_ List;

List * initialise_list();
int insert_data_beg(List *, int);
int insert_data_end(List *, int);
int insert_data_after_element(List *, int data, int element);
int insert_and_sort(List *, int);
int search(List *, int);

int delete_at_beg(List *);
int delete_at_end(List *);
int delete_element(List *, int element);


int merge_list(List *, List *); // practice lab
List * intersection(List *, List *); // practice lab
List * split_at_index(List *, int index); // practice lab
List *sort(List *);
List *deallocate_list(List *);
List * delete_duplicate_element(List *); // practice lab
int delete_occurence_element(List *, int);

#endif // LIST_HEADER


//list_op.c file
#include <stdlib.h>
#include "list.h"
#define IS_NULL(PTR) PTR == NULL

List * initialise_list()
{
    List *my_list;

    my_list = (List *)malloc(sizeof(List));
    if(my_list == NULL) return ALLOC_FAIL;

    my_list->head = my_list->tail = NULL;
    my_list->count = 0;

    return my_list;
}
Node *get_node(int data)
{
    Node *new_node;

    new_node = (Node *)malloc(sizeof(Node));
    if(new_node == NULL) return NODE_ALLOC_FAIL;
    new_node->data = data;
    new_node->ptr = NULL;

    return new_node;
}
int insert_data_beg(List *my_list, int data)
{
    Node *new_node = get_node(data);
    if(new_node == NODE_ALLOC_FAIL) return INSERT_FAIL;

    if(my_list->count == 0) // insert first element
        my_list->head = my_list->tail = new_node;
    else
    {
        new_node->ptr = my_list->head;
        my_list->head = new_node;
    }
    my_list->count++;
    return SUCCESS;
}

int insert_data_end(List *my_list, int data)
{
    Node *new_node = get_node(data);
    if(new_node == NODE_ALLOC_FAIL) return INSERT_FAIL;

    if(my_list->count == 0) // insert first element
        my_list->head = my_list->tail = new_node;
    else
    {
        my_list->tail->ptr = new_node; // insert at end
        my_list->tail = new_node; // update tail address
    }
    my_list->count++;
    return SUCCESS;
}


int search(List *my_list, int element)
{
    Node *temp;

    for(temp = my_list->head; temp != NULL; temp = temp->ptr)
        if(temp->data == element) return FOUND;
    return NOT_FOUND;
}
Node *get_node_address(List *my_list,int element)
{
    Node *temp;

    for(temp = my_list->head; temp != NULL; temp = temp->ptr)
        if(temp->data == element) return temp;
    return NULL;
}


int insert_data_after_element(List *my_list, int data, int element)
{
    Node *temp, *new_node;

    temp = get_node_address(my_list, element);
    if(IS_NULL(temp)) return INSERT_FAIL;

    new_node = get_node(data);
    if(IS_NULL(new_node)) return INSERT_FAIL;

    new_node->ptr = temp->ptr;
    temp->ptr = new_node;
    if(temp == my_list->tail) my_list->tail = new_node;
    my_list->count++;

    return SUCCESS;
}

Node * get_node_last_min_addr(List *my_list,int data)
{
    Node *temp;

    for(temp = my_list->head; temp->ptr!=NULL && temp->ptr->data < data;//
    temp = temp->ptr);

    return temp;
}
int insert_and_sort(List *my_list, int data)
{
    if(my_list->count == 0)
        return insert_data_beg(my_list, data);
    if(my_list->head->data > data)
        return insert_data_beg(my_list, data);
    if(my_list->tail->data < data)
        return insert_data_end(my_list, data);

    Node *temp = get_node_last_min_addr(my_list, data);

    Node *new_node = get_node(data);
    new_node->ptr = temp->ptr;
    temp->ptr = new_node;
    my_list->count++;

    return SUCCESS;
}

int insert_and_sort_with_prev(List *my_list, int data)
{
    Node *temp, *prev, *new_node;

     new_node = get_node(data);
    if(my_list->count == 0)
        my_list->head= my_list->tail = new_node;
    if(my_list->head->data > data)
    {
        new_node->ptr = my_list->head;
        my_list->head = new_node;
    }
    //write code to insert data at tail

    for(temp = my_list->head; temp->ptr != NULL && temp->data < data; prev = temp,temp = temp->ptr)
    {
        prev->ptr = new_node;
        new_node->ptr = temp;
    }
    my_list->count++;
    return SUCCESS;
}

int delete_at_beg(List *my_list)
{
    Node *temp;
    int result;

    if(my_list->count == 0) return LIST_EMPTY;
    result = my_list->head->data;
    if(my_list->count == 1)
    {
        free(my_list->head);
        my_list->head = my_list->tail = NULL;
    }
    else{
        temp = my_list->head;
        my_list->head = my_list->head->ptr;
        free(temp);
    }
    my_list->count--;

    return result;
}
Node * get_n_minus_one_node_addr(List *my_list)
{
    Node *temp;

    for(temp=my_list->head; temp->ptr != my_list->tail; temp= temp->ptr);
    return temp;
}

int delete_at_end(List *my_list)
{
     Node *temp;
    int result;

    if(my_list->count == 0) return LIST_EMPTY;
    result = my_list->tail->data;
    if(my_list->count == 1)
    {
        free(my_list->head);
        my_list->head = my_list->tail = NULL;
    }
    else
    {
        temp = get_n_minus_one_node_addr(my_list);
        free(temp->ptr);
        temp->ptr = NULL;
        my_list->tail = temp;
    }
    my_list->count--;
    return result;
}

int delete_element(List *my_list, int ele)
{
    Node *temp, *prev;
    int result;

    if(my_list->count == 0) return LIST_EMPTY;

    if(my_list->head->data == ele)
        return delete_at_beg(my_list);
    if(my_list->tail->data == ele)
        return delete_at_end(my_list);

    for(temp = my_list->head;//
     temp != NULL && temp->data != ele;//
     prev=temp, temp = temp->ptr);

     if(temp == NULL) return NOT_FOUND;
     result = temp->data;
     prev->ptr = temp->ptr;
     free(temp);
     my_list->count--;

     return result;

}
int delete_occurence_element(List *my_list, int ele)
{

    int count=0, i;
    //Node *temp;
    int total_ele = my_list->count;
    for(i=0; i<total_ele;i++)
    {
        if(delete_element(my_list, ele) == ele){
            count++;
            continue;
    }
    else
        break;
    }
    return count;
}

List *deallocate_list(List *my_list)
{
    Node *temp = my_list->head;

    if(my_list == NULL)  return NULL;
    while(my_list->head != NULL)
    {
        my_list->head = my_list->head->ptr;
        free(temp);
        temp = my_list->head;
    }
    free(my_list);
    return NULL;
}


//main.c file
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "list.h"
void test_delete_beg();
void test_delete_end();
void test_delete_element();
void test_occurence_element();
int main()
{
    List *test, *new_list;

    new_list = initialise_list();


    test = initialise_list();
    assert(test != NULL);
    assert(test->head == NULL && test->tail == NULL);
    assert(test->count == 0);

    assert(insert_data_beg(test, 10));
    assert(insert_data_beg(test, 20));
    assert(insert_data_beg(test, 30));
    assert(insert_data_beg(test, 40));
    assert(insert_data_beg(test, 50));
    assert(insert_data_beg(test, 60));
    assert(test->count == 6);
    assert(test->head->data == 60);
    assert(test->tail->data == 10);
    assert(test->head->ptr->ptr->ptr->data == 30);

    assert(search(test, 10));
    assert(search(test, 30));
    assert(search(test, 50));
    assert(search(test, 60));
    assert(search(test, 70) == NOT_FOUND);

    assert(insert_data_after_element(test, 45,40));
    assert(test->head->ptr->ptr->ptr->data == 45);
    assert(insert_data_after_element(test, 5,10));
    assert(test->tail->data == 5);
    assert(insert_data_after_element(test, 70,60));
    assert(test->head->ptr->data == 70);

    test= deallocate_list(test);
    assert(test == NULL);
    new_list= deallocate_list(new_list);
    assert(new_list == NULL);
    test_delete_beg();
    test_delete_end();
    test_delete_element();
    test_occurence_element();
    return 0;
}

void test_delete_beg()
{
    List *test;

    test = initialise_list();
    assert(test != NULL);
    assert(test->head == NULL && test->tail == NULL);
    assert(test->count == 0);

    assert(insert_data_beg(test, 10));
    assert(insert_data_beg(test, 20));
    assert(insert_data_beg(test, 30));
    assert(insert_data_beg(test, 40));
    assert(insert_data_beg(test, 50));
    assert(insert_data_beg(test, 60));
    assert(test->count == 6);
    assert(delete_at_beg(test) == 60);
    assert(delete_at_beg(test) == 50);
    assert(delete_at_beg(test) == 40);
    assert(delete_at_beg(test) == 30);
    assert(delete_at_beg(test) == 20);
    assert(delete_at_beg(test) == 10);
    assert(test->count == 0);
    assert(test->head == NULL && test->tail == NULL);
    assert(delete_at_beg(test) == LIST_EMPTY);


    test= deallocate_list(test);
    assert(test == NULL);
}

void test_delete_end()
{
    List *test, *new_list;

    test = initialise_list();
    assert(test != NULL);
    assert(test->head == NULL && test->tail == NULL);
    assert(test->count == 0);

    assert(insert_data_beg(test, 10));
    assert(insert_data_beg(test, 20));
    assert(insert_data_beg(test, 30));
    assert(insert_data_beg(test, 40));

    assert(test->count == 4);
    assert(delete_at_end(test) == 10);
    assert(delete_at_end(test) == 20);
    assert(delete_at_end(test) == 30);
    assert(test->head == test->tail);
    assert(delete_at_end(test) == 40);
    assert(test->count == 0);
    assert(test->head == NULL && test->tail == NULL);
    assert(delete_at_beg(test) == LIST_EMPTY);


    test= deallocate_list(test);
    assert(test == NULL);
}
void test_delete_element()
{
    List *test, *new_list;

    test = initialise_list();
    assert(test != NULL);
    assert(test->head == NULL && test->tail == NULL);
    assert(test->count == 0);

    assert(insert_data_beg(test, 10));
    assert(insert_data_beg(test, 20));
    assert(insert_data_beg(test, 30));
    assert(insert_data_beg(test, 40));

    assert(test->count == 4);
    assert(delete_element(test, 30) == 30);
    assert(delete_element(test, 10) == 10);
    assert(delete_element(test, 40) == 40);
    assert(delete_element(test, 10) == NOT_FOUND);
    assert(test->head == test->tail);
    assert(delete_element(test, 20) == 20);
    assert(test->head == NULL && test->tail == NULL);

    test= deallocate_list(test);
    assert(test == NULL);
}
void test_occurence_element()
{
  List *test, *new_list;

    test = initialise_list();
    assert(test != NULL);
    assert(test->head == NULL && test->tail == NULL);
    assert(test->count == 0);

    assert(insert_data_beg(test, 20));
    assert(insert_data_beg(test, 20));
    assert(insert_data_beg(test, 20));
    assert(insert_data_beg(test, 20));
    assert(insert_data_beg(test, 20));

    assert(test->count == 5);
    assert(delete_occurence_element(test, 20) == 5);
    assert(test->count == 0);

    test= deallocate_list(test);
    assert(test == NULL);
}

//use this n customise the below question for exam, it should be like student written code
